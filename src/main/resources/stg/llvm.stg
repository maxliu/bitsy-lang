file(fileName, strings, locals, block) ::= <<
@.newline = internal constant [2 x i8] c"\0A\00"
@.double = internal constant [3 x i8] c"%g\00"
@.true = internal constant [5 x i8] c"true\00"
@.false = internal constant [6 x i8] c"false\00"
<strings:{s | @.str<i> = internal constant <llvmConstant(s)>}; separator="\n">

declare i32 @printf(i8 *, ...)

define i32 @main() {
    <block>
    ret i32 0;
}
>>

block(symbols, statements, scope) ::= <<
<symbols:{ s | %<s.name> = alloca <symbolType(s.type)>}; separator="\n">
<statements;separator="\n">
>>

println(value, scope) ::= <<
<if(value&&value.reference)>
<if(value.string)>
%r<scope.nextRegister> = load i8** %<value> 
call i32 (i8 *, ...)* @printf(i8* %r<scope.register>)
<elseif(value.number)>
%r<scope.nextRegister> = load double* %<value> 
call i32 (i8 *, ...)* @printf(i8* getelementptr ([3 x i8]* @.double, i32 0, i32 0), double %r<scope.register>)
<elseif(value.boolean)>
%r<scope.nextRegister> = load i32* %<value>
%c<scope.register> = icmp ne i32 %r<scope.register>, 0
br i1 %c<scope.register>, label %true<scope.register>, label %false<scope.register>
true<scope.register>: 
	call i32 (i8 *, ...)* @printf(i8* getelementptr ([5 x i8]* @.true, i32 0, i32 0))
	br label %endif<scope.register>
false<scope.register>:
	call i32 (i8 *, ...)* @printf(i8* getelementptr ([6 x i8]* @.false, i32 0, i32 0))
	br label %endif<scope.register>
endif<scope.register>:
<endif>
<elseif(value)>
<if(value.string)>
call i32 (i8 *, ...)* @printf(i8* <getString(value)>)
<elseif(value.number)>
call i32 (i8 *, ...)* @printf(i8* getelementptr ([3 x i8]* @.double, i32 0, i32 0), double <value>)
<elseif(value.boolean)>
<if(value.onTrue)>
call i32 (i8 *, ...)* @printf(i8* getelementptr ([5 x i8]* @.true, i32 0, i32 0))
<else>
call i32 (i8 *, ...)* @printf(i8* getelementptr ([6 x i8]* @.false, i32 0, i32 0))
<endif>
<endif>
<endif>call i32 (i8 *, ...)* @printf(i8* getelementptr ([2 x i8]* @.newline, i32 0, i32 0))
>>

assignment(name, value, scope) ::= <<
<if(value.reference)>
%r<scope.nextRegister> = load <llvmType(value)>* %<value>
store <llvmType(value)> %r<scope.register>, <llvmType(value)>* %<name><else>
store <llvmType(value)> <llvmValue(value)>, <llvmType(value)>* %<name><endif>
>>

ifStat(value, block, scope, label, sublevel) ::= <<
<compareValToZero(value, scope)>
br i1 %c<scope.register>, label %true<label>_<sublevel>, label %false<label>_<sublevel>
true<label>_<sublevel>: 
	<block>
	br label %endif<label>
false<label>_<sublevel>:

>>

elseifStat(value, block, scope, label, sublevel) ::= "<ifStat(value, block, scope, label, sublevel)>"

elseStat(block, label) ::= <<
	<block>
>>

endifStat(label) ::= <<
	br label %endif<label>
endif<label>:
>>

compareValToZero(value, scope) ::= <<
<if(value.reference)>
<if(value.boolean)>
%r<scope.nextRegister> = load i32* %<value>
%c<scope.register> = icmp ne i32 %r<scope.register>, 0<elseif(value.number)>
%r<scope.nextRegister> = load double* %<value>
%c<scope.register> = fcmp une double %r<scope.register>, 0.0<else>
%r<scope.nextRegister> = load i8** %<value>
%r<scope.nextRegister> = load i8* %r<scope.lastRegister>
%c<scope.register> = icmp ne i8 %r<scope.register>, 0<endif>
<else>
%r<scope.nextRegister> = add i32 0, <value.toBoolean>
%c<scope.register> = icmp ne i32 %r<scope.register>, 0<endif>
>>

typeMap ::= [
	"string": "i8*",
	"number": "double",
	"boolean": "i32"
]

symbolType(type) ::= "<typeMap.(type.name)>"
llvmConstant(s) ::= <<[<(s.LLVMLength)> x i8] c"<s.LLVMString>">>
llvmType(v) ::= "<if(v.number)>double<elseif(v.boolean)>i32<else>i8*<endif>"
llvmValue(v) ::= "<if(v.reference)>%<v><elseif(v.string)><getString(v)><else><v><endif>"
getString(s) ::= "getelementptr ([<s.LLVMLength> x i8]* @.str<s.register>, i32 0, i32 0)"