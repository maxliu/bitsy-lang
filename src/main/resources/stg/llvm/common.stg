addToList(register, i, length, value) ::= <<
%item<register>_<i> = getelementptr inbounds [<length> x %struct.Object]* %item_array<register>, i32 0, i64 <i>
%item<register>_type_<i> = getelementptr inbounds %struct.Object* %item<register>_<i>, i32 0, i32 0
%item<register>_value_<i> = getelementptr inbounds %struct.Object* %item<register>_<i>, i32 0, i32 1
<loadOperand(value, register, prefixIndex("item", i))>
<if(value.boolean)> 
store i32 2, i32* %item<register>_type_<i>
%item<register>_value_union_<i> = bitcast %union.Value* %item<register>_value_<i> to i32*
store i32 <argRegister(value, prefixIndex("item", i), register)>, i32* %item<register>_value_union_<i>
<elseif(value.number)>
store i32 1, i32* %item<register>_type_<i>
%item<register>_value_union_<i> = bitcast %union.Value* %item<register>_value_<i> to double*
store double <argRegister(value, prefixIndex("item", i), register)>, double* %item<register>_value_union_<i>
<elseif(value.string)>
store i32 0, i32* %item<register>_type_<i>
%item<register>_value_union_<i> = bitcast %union.Value* %item<register>_value_<i> to i8**
store i8* <argRegister(value, prefixIndex("item", i), register)>, i8** %item<register>_value_union_<i>
<elseif(value.list)>
store i32 5, i32* %item<register>_type_<i>
%item<register>_value_union_<i> = bitcast %union.Value* %item<register>_value_<i> to %struct.List**
store %struct.List* <argRegister(value, prefixIndex("item", i), register)>, %struct.List** %item<register>_value_union_<i>
<else>
store i32 3, i32* %item<register>_type_<i>
<endif>
>>


bopExpression(lval, rval, scope, op) ::= <<
<loadOperands(lval, rval, scope)>
<if(lval.string&&rval.string)>
%r<scope.nextRegister> = call i32 @strcmp(<args(lval, rval, scope)>)
%r<scope.nextRegister> = icmp s<opMap.(op)> i32 %r<scope.lastRegister>, 0
<elseif(lval.string&&rval.number)>
%r<scope.register> = call double @atof(i8* <argRegister(lval,"lval",scope.register)>)
%r<scope.nextRegister> = fsub double %r<scope.lastRegister>, <argRegister(rval,"rval",scope.lastRegister)>
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<elseif(lval.number&&rval.string)>
%r<scope.register> = call double @atof(i8* <argRegister(rval,"rval",scope.register)>)
%r<scope.nextRegister> = fsub double <argRegister(lval,"lval",scope.lastRegister)>, %r<scope.lastRegister> 
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<elseif(lval.number&&rval.number)>
%r<scope.register> = fsub double <argRegister(lval,"lval",scope.register)>, <argRegister(rval,"rval",scope.register)>
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<endif>
>>

loadOperand(val, register, prefix="r") ::= <%
<if(val.symbol&&val.string)><loadString(val, prefix, register)>
<elseif(val.symbol&&val.number)><loadNumber(val, prefix, register)>
<elseif(val.symbol&&val.boolean)><loadBoolean(val, prefix, register)>
<elseif(val.symbol&&val.list)>%<prefix><register> = load %struct.List** %<bitsyVariable(val)>
<endif>
%>

loadOperands(lval, rval, scope) ::= <<
<loadOperand(lval, scope.register, "lval")>
<loadOperand(rval, scope.register, "rval")>
>>

compareRegToZero(prefix, value, register, lastRegister, op="eq") ::= <<
<if(value.string)>
%<prefix><register> = load i8* <argRegister(value, prefix, lastRegister)>
%<prefix>_sext<register> = sext i8 %<prefix><register> to i32
%<prefix>_cmp<register> = icmp <op> i32 %<prefix>_sext<register>, 0
<elseif(value.number)>
%<prefix><register> = fadd double <argRegister(value, prefix, lastRegister)>, 0.0
%<prefix>_cmp<register> = fcmp u<op> double %<prefix><register>, 0.000000e+00
<elseif(value.boolean)>
%<prefix><register> = add i1 <argRegister(value, prefix, lastRegister)>, 0
%<prefix>_cmp<register> = icmp <op> i1 %<prefix><register>, 0
<endif>
>>

compareValToZero(value, register) ::= <<
<if(value.symbol)>
<if(value.boolean)>
%r<register> = load i1* %<bitsyVariable(value)>
%c<register> = icmp ne i1 %r<register>, 0<elseif(value.number)>
%r<register> = load double* %<bitsyVariable(value)>
%c<register> = fcmp une double %r<register>, 0.0<else>
%r<register> = load i8** %<bitsyVariable(value)>
%s<register> = load i8* %r<register>
%c<register> = icmp ne i8 %s<register>, 0<endif>
<elseif(value.reference)>
<if(value.boolean)>
%c<register> = icmp ne i1 %r<value>, 0<elseif(value.number)>
%c<register> = fcmp une double %r<value>, 0.0<else>
%s<register> = load i8* %r<value>
%c<register> = icmp ne i8 %s<register>, 0<endif>
<else>
%r<register> = add i1 0, <value.toBoolean>
%c<register> = icmp ne i1 %r<register>, 0<endif>
>>

opMap ::= [
	"<": "lt",
	"<=": "le",
	">": "gt",
	">=": "ge"
]


typeMap ::= [
    "string": "i8*",
    "number": "double",
    "boolean": "i1",
    "null": "void",
    "list": "%struct.List*"
]

returnMap ::= [
	"string": "0",
	"number": "0.0",
	"boolean": "0",
	"null": ""
]

storeResult(value, prefix, register, temp="tmp") ::= <<
<if(value.symbol)>
%<temp><scope.register> = load <llvmType(value)>* %<bitsyVariable(value)>
store <typeMap.(value.type)> %<temp><scope.register>, <typeMap.(value.type)>* %<prefix><register>
<elseif(value.reference)>
store <typeMap.(value.type)> %r<value>,<typeMap.(value.type)>* %<prefix><register>  
<elseif(value.string)>
store i8* <getString(value)>, i8** %<prefix><register>
<elseif(value.number)>
store double <value>, double* %<prefix><register>
<elseif(value.boolean)>
store i1 <value>, i1* %<prefix><register>
<endif>
>>

prefixIndex(prefix, index) ::= <%
<prefix><index>_
%>

loadList(args, register) ::= <%
<args:{arg | <loadOperand(arg, register, prefixIndex("args",i))>}; separator="\n">
%>

typeList(args) ::= <%
<args:{arg | <typeMap.(arg.type)>}; separator=", ">
%>

argsList(args, register) ::= <%
<args:{arg | <typeMap.(arg.type)> <argRegister(arg, prefixIndex("args", i), register)>}; separator=", ">
%>

args(lval, rval, scope) ::= <%
<typeMap.(lval.type)> <argRegister(lval, "lval", scope.register)>, <typeMap.(rval.type)> <argRegister(rval, "rval", scope.register)>
%>

argRegister(val, prefix, register) ::= <%
<if(val.reference&&!val.symbol)>%r<val>
<elseif(val.symbol)>%<prefix><register>
<elseif(val.string)><getString(val)>
<else><val><endif>
%>

loadString(val, side, register) ::= "%<side><register> = load i8** %<bitsyVariable(val)>"
loadNumber(val, side, register) ::= <%
<if(val.reference)>
%<side><register> = load double* %<bitsyVariable(val)>
<else>
%<side><register> = fadd double 0.0, <val>
<endif>
%>
loadBoolean(val, side, register) ::= "%<side><register> = load i1* %<bitsyVariable(val)>"

bitsyVariable(name) ::= "$<name>"
symbolType(type) ::= "<typeMap.(type.name)>"
llvmConstant(s) ::= <<[<(s.LLVMLength)> x i8] c"<s.LLVMString>">>
llvmType(v) ::= "<typeMap.(v.type)>"
llvmValue(v) ::= "<if(v.reference)>%<v><elseif(v.string)><getString(v)><else><v><endif>"
getString(s) ::= "getelementptr ([<s.LLVMLength> x i8]* @.str<s.register>, i32 0, i32 0)"