bopExpression(lval, rval, scope, op) ::= <<
<loadOperands(lval, rval, scope)>
<if(lval.string&&rval.string)>
%r<scope.nextRegister> = call i32 @strcmp(<args(lval, rval, scope)>)
%r<scope.nextRegister> = icmp s<opMap.(op)> i32 %r<scope.lastRegister>, 0
<elseif(lval.string&&rval.number)>
%r<scope.register> = call double @atof(i8* <argRegister(lval,"lval",scope.register)>)
%r<scope.nextRegister> = fsub double %r<scope.lastRegister>, <argRegister(rval,"rval",scope.lastRegister)>
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<elseif(lval.number&&rval.string)>
%r<scope.register> = call double @atof(i8* <argRegister(rval,"rval",scope.register)>)
%r<scope.nextRegister> = fsub double <argRegister(lval,"lval",scope.lastRegister)>, %r<scope.lastRegister> 
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<elseif(lval.number&&rval.number)>
%r<scope.register> = fsub double <argRegister(lval,"lval",scope.register)>, <argRegister(rval,"rval",scope.register)>
%r<scope.nextRegister> = fcmp o<opMap.(op)> double %r<scope.lastRegister>, 0.0
<endif>
>>

loadOperand(val, register, prefix="r") ::= <%
<if(val.symbol&&val.string)><loadString(val, prefix, register)>
<elseif(val.symbol&&val.number)><loadNumber(val, prefix, register)>
<elseif(val.symbol&&val.boolean)><loadBoolean(val, prefix, register)>
<endif>
%>

loadOperands(lval, rval, scope) ::= <<
<loadOperand(lval, scope.register, "lval")>
<loadOperand(rval, scope.register, "rval")>
>>

compareRegToZero(prefix, value, register, lastRegister, op="eq") ::= <<
<if(value.string)>
%<prefix><register> = load i8* <argRegister(value, prefix, lastRegister)>
%<prefix>_sext<register> = sext i8 %<prefix><register> to i32
%<prefix>_cmp<register> = icmp <op> i32 %<prefix>_sext<register>, 0
<elseif(value.number)>
%<prefix><register> = fadd double <argRegister(value, prefix, lastRegister)>, 0.0
%<prefix>_cmp<register> = fcmp u<op> double %<prefix><register>, 0.000000e+00
<elseif(value.boolean)>
%<prefix><register> = add i1 <argRegister(value, prefix, lastRegister)>, 0
%<prefix>_cmp<register> = icmp <op> i1 %<prefix><register>, 0
<endif>
>>

compareValToZero(value, scope) ::= <<
<if(value.symbol)>
<if(value.boolean)>
%r<scope.nextRegister> = load i1* %<bitsyVariable(value)>
%c<scope.register> = icmp ne i1 %r<scope.register>, 0<elseif(value.number)>
%r<scope.nextRegister> = load double* %<bitsyVariable(value)>
%c<scope.register> = fcmp une double %r<scope.register>, 0.0<else>
%r<scope.nextRegister> = load i8** %<bitsyVariable(value)>
%r<scope.nextRegister> = load i8* %r<scope.lastRegister>
%c<scope.register> = icmp ne i8 %r<scope.register>, 0<endif>
<elseif(value.reference)>
<if(value.boolean)>
%c<scope.nextRegister> = icmp ne i1 %r<value>, 0<elseif(value.number)>
%c<scope.nextRegister> = fcmp une double %r<value>, 0.0<else>
%r<scope.nextRegister> = load i8* %r<value>
%c<scope.register> = icmp ne i8 %r<scope.register>, 0<endif>
<else>
%r<scope.nextRegister> = add i1 0, <value.toBoolean>
%c<scope.register> = icmp ne i1 %r<scope.register>, 0<endif>
>>

opMap ::= [
	"<": "lt",
	"<=": "le",
	">": "gt",
	">=": "ge"
]


typeMap ::= [
    "string": "i8*",
    "number": "double",
    "boolean": "i1",
    "void": "void"
]

storeResult(value, prefix, register, temp="tmp") ::= <<
<if(value.symbol)>
%<temp><scope.register> = load <llvmType(value)>* %<bitsyVariable(value)>
store <typeMap.(value.type)> %<temp><scope.register>, <typeMap.(value.type)>* %<prefix><register>
<elseif(value.reference)>
store <typeMap.(value.type)> %r<value>,<typeMap.(value.type)>* %<prefix><register>  
<elseif(value.string)>
store i8* <getString(value)>, i8** %<prefix><register>
<elseif(value.number)>
store double <value>, double* %<prefix><register>
<elseif(value.boolean)>
store i1 <value>, i1* %<prefix><register>
<endif>
>>

args(lval, rval, scope) ::= <%
<typeMap.(lval.type)> <argRegister(lval, "lval", scope.register)>, <typeMap.(rval.type)> <argRegister(rval, "rval", scope.register)>
%>

argRegister(val, prefix, register) ::= <%
<if(val.reference&&!val.symbol)>%r<val>
<elseif(val.symbol)>%<prefix><register>
<elseif(val.string)><getString(val)>
<else><val><endif>
%>

loadString(val, side, register) ::= "%<side><register> = load i8** %<bitsyVariable(val)>"
loadNumber(val, side, register) ::= <%
<if(val.reference)>
%<side><register> = load double* %<bitsyVariable(val)>
<else>
%<side><register> = fadd double 0.0, <val>
<endif>
%>
loadBoolean(val, side, register) ::= "%<side><register> = load i1* %<bitsyVariable(val)>"


bitsyVariable(name) ::= "$<name>"
symbolType(type) ::= "<typeMap.(type.name)>"
llvmConstant(s) ::= <<[<(s.LLVMLength)> x i8] c"<s.LLVMString>">>
llvmType(v) ::= "<if(v.number)><typeMap.number><elseif(v.boolean)><typeMap.boolean><else><typeMap.string><endif>"
llvmValue(v) ::= "<if(v.reference)>%<v><elseif(v.string)><getString(v)><else><v><endif>"
getString(s) ::= "getelementptr ([<s.LLVMLength> x i8]* @.str<s.register>, i32 0, i32 0)"